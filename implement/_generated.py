
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    
    listAggVars = ['cust']
    numGroupVars = 4
    suchthat = ['1.state = 1.state', '2.state = 2.state', "3.state = 'CT'", '4.cust = cust']
    # having = None
    rowDict = {}  # renamed to rowDict from dict
    #dataDict = {} just data for the keys not the final value
    ATTRIBUTE_INDEX = {'cust': 0, 'prod': 1, 'day': 2, 'month': 3, 'year': 4, 'state': 5, 'quant': 6, 'date': 7}

    
    for row in cur: # loop to put all keys in dictionary
        #_global.append(row)
        uniqueID = "" # this is gonna be a combination of the agg vars for the rowDict key
        for aggVar in listAggVars:
            uniqueID = uniqueID + row[aggVar]
        rowDict[uniqueID] = {}

        grpList = []     # list of the grouping variables' indices
        for get_var in listAggVars:
            grpList.append(ATTRIBUTE_INDEX[get_var])    # turn them into indices so we can pass them over to the aggregates
            rowDict[uniqueID][get_var] = row[ATTRIBUTE_INDEX[get_var]]
            # print(grpList)
        
        # for index in grpList:   # grouping vars
        #     # print(str(index) + ": ADD " + str(row[index]))
        #     rowDict[uniqueID][row[index]] = row[index]   # replaced with index

        for groupVar in range(numGroupVars):   # for group in n
            for agg in [[('1', 'count', 'quant')], [('2', 'max', 'quant')], [('3', 'max', 'quant')], [('4', 'max', 'quant')]][groupVar]:
                if agg[1] == "count":
                    rowDict[uniqueID][str(groupVar + 1) + "_count_" + agg[2]] = 0
                if agg[1] == "sum":
                    rowDict[uniqueID][str(groupVar + 1) + "_sum_" + agg[2]] = 0
                if agg[1] == "max":
                    rowDict[uniqueID][str(groupVar + 1) + "_max_" + agg[2]] = 0
                if agg[1] == "min":
                    rowDict[uniqueID][str(groupVar + 1) + "_min_" + agg[2]] = 0
                if agg[1] == "avg":
                    rowDict[uniqueID][str(groupVar + 1) + "_sumAvg_" + agg[2]] = 0
                    rowDict[uniqueID][str(groupVar + 1) + "_countAvg_" + agg[2]] = 0
                    rowDict[uniqueID][str(groupVar + 1) + "_avg_" + agg[2]] = 0

                                        
    cur.execute("SELECT * FROM sales")


    
    for groupVar in range(numGroupVars): #loop, for group in n, to calculate all the aggregates
        for row in cur:
            uniqueID = "" # this is gonna be a combination of the agg vars for the rowDict key
            for aggVar in listAggVars:
                uniqueID = uniqueID + row[aggVar]

            for agg in [[('1', 'count', 'quant')], [('2', 'max', 'quant')], [('3', 'max', 'quant')], [('4', 'max', 'quant')]][groupVar]:
                if groupVar == 0 and (row[ATTRIBUTE_INDEX['state']] == row[ATTRIBUTE_INDEX['state']]) or groupVar == 1 and (row[ATTRIBUTE_INDEX['state']] == row[ATTRIBUTE_INDEX['state']]) or groupVar == 2 and (row[ATTRIBUTE_INDEX['state']] == 'CT') or groupVar == 3 and (row[ATTRIBUTE_INDEX['cust']] == rowDict[uniqueID]['cust']):   # where the conditional happens, grouped up by grouping vars
                    if agg[1] == "count":
                        rowDict[uniqueID][str(groupVar + 1) + "_count_" + agg[2]] += 1
                    if agg[1] == "sum":
                        rowDict[uniqueID][str(groupVar + 1) + "_sum_" + agg[2]] += row[agg[2]]
                    if agg[1] == "max":
                        if(row[agg[2]] > rowDict[uniqueID][str(groupVar + 1) + "_max_" + agg[2]]):
                            rowDict[uniqueID][str(groupVar + 1) + "_max_" + agg[2]] = row[agg[2]]
                    if agg[1] == "min":
                        if(row[agg[2]] < rowDict[uniqueID][str(groupVar + 1) + "_min_" + agg[2]]):
                            rowDict[uniqueID][str(groupVar + 1) + "_min_" + agg[2]] = row[agg[2]]
                    if agg[1] == "avg":
                        rowDict[uniqueID][str(groupVar + 1) + "_sumAvg_" + agg[2]] += row[agg[2]]
                        rowDict[uniqueID][str(groupVar + 1) + "_countAvg_" + agg[2]] += 1
        
        for agg in [[('1', 'count', 'quant')], [('2', 'max', 'quant')], [('3', 'max', 'quant')], [('4', 'max', 'quant')]][groupVar]:
            for uniqueID in list(rowDict.keys()):
                if agg[1] == "avg":
                    #print("here")
                    #print(rowDict[uniqueID][str(groupVar + 1) + "_sumAvg_" + agg[2]])
                    #print(rowDict[uniqueID][str(groupVar + 1) + "_countAvg_" + agg[2]])
                    rowDict[uniqueID][str(groupVar + 1) + "_avg_" + agg[2]] =  rowDict[uniqueID][str(groupVar + 1) + "_sumAvg_" + agg[2]] / rowDict[uniqueID][str(groupVar + 1) + "_countAvg_" + agg[2]]
                    del rowDict[uniqueID][str(groupVar + 1) + "_sumAvg_" + agg[2]]
                    del rowDict[uniqueID][str(groupVar + 1) + "_countAvg_" + agg[2]]
                    #print(rowDict[uniqueID][str(groupVar + 1) + "_avg_" + agg[2]])
                    #print("there")
        

        cur.execute("SELECT * FROM sales")
    
    for groupVar in range(numGroupVars): # have to run a second series of loops to allow averages to be computed first before having
        for agg in [[('1', 'count', 'quant')], [('2', 'max', 'quant')], [('3', 'max', 'quant')], [('4', 'max', 'quant')]][groupVar]:  
            for uniqueID in list(rowDict.keys()): 
                # print(list(rowDict[uniqueID].keys()))
                if not (True):
                    # print("it happened")
                    del rowDict[uniqueID]
                    
    for att in ['cust', '1_count_quant', '2_max_quant', '3_max_quant / 4_max_quant']:
        for uniqueID in list(rowDict.keys()): 
            if(att not in ['cust'] and att not in ['1_count_quant', '2_max_quant', '3_max_quant', '4_max_quant']):
                result = att
                for substring in ['1_count_quant', '2_max_quant', '3_max_quant', '4_max_quant']: # get the 1_avg_quant stuff
                    if substring in result:
                        result = result.replace(substring, "rowDict[uniqueID]['" + substring + "']")
                        #print(temp)
                rowDict[uniqueID][att] = eval(result)
            
    for groupVar in range(numGroupVars): # NEED ANOTHER SERIES OF LOOP FOR NO ERROR
        for agg in [[('1', 'count', 'quant')], [('2', 'max', 'quant')], [('3', 'max', 'quant')], [('4', 'max', 'quant')]][groupVar]:  
            for uniqueID in list(rowDict.keys()): 
                if(att in ['cust'] or att in ['1_count_quant', '2_max_quant', '3_max_quant', '4_max_quant']):
                    if not ((str(groupVar + 1) + "_count_" + agg[2]) in ['cust', '1_count_quant', '2_max_quant', '3_max_quant / 4_max_quant']):
                        (rowDict[uniqueID]).pop(str(groupVar + 1) + "_count_" + agg[2], None)
                    if not ((str(groupVar + 1) + "_sum_" + agg[2]) in ['cust', '1_count_quant', '2_max_quant', '3_max_quant / 4_max_quant']):
                        (rowDict[uniqueID]).pop(str(groupVar + 1) + "_sum_" + agg[2], None)
                    if not ((str(groupVar + 1) + "_max_" + agg[2]) in ['cust', '1_count_quant', '2_max_quant', '3_max_quant / 4_max_quant']):
                        (rowDict[uniqueID]).pop(str(groupVar + 1) + "_max_" + agg[2], None)
                    if not ((str(groupVar + 1) + "_min_" + agg[2]) in ['cust', '1_count_quant', '2_max_quant', '3_max_quant / 4_max_quant']):
                        (rowDict[uniqueID]).pop(str(groupVar + 1) + "_min_" + agg[2], None)
                    if not ((str(groupVar + 1) + "_avg_" + agg[2]) in ['cust', '1_count_quant', '2_max_quant', '3_max_quant / 4_max_quant']):
                        (rowDict[uniqueID]).pop(str(groupVar + 1) + "_avg_" + agg[2], None)
    print(rowDict.keys())

    
    

    
    # test of sorting to compare with sql
    the_keys = list(rowDict.keys())
    the_keys.sort()
    sd = {i: rowDict[i] for i in the_keys}

    for x in list(sd.values()):
        _global.append(list(x.values()))
    
    return tabulate.tabulate(_global,
                        headers=list(sd[list(sd.keys())[0]].keys()), tablefmt="postgres")

def main():
    print(query())
    #query()
    
if "__main__" == __name__:
    main()
    